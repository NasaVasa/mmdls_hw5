{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# HW5 Bitcoin Testnet\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ee8b4ed2",
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "import os, json, time, hashlib, requests\n",
        "from ecdsa import SigningKey, SECP256k1, util\n",
        "\n",
        "BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n",
        "\n",
        "def sha256(b: bytes) -> bytes:\n",
        "    return hashlib.sha256(b).digest()\n",
        "\n",
        "def hash256(b: bytes) -> bytes:\n",
        "    return sha256(sha256(b))\n",
        "\n",
        "def _ripemd160_py(data: bytes) -> bytes:\n",
        "    def rol(x, n):\n",
        "        return ((x << n) | (x >> (32 - n))) & 0xffffffff\n",
        "\n",
        "    def f(j, x, y, z):\n",
        "        if 0 <= j <= 15:\n",
        "            return x ^ y ^ z\n",
        "        if 16 <= j <= 31:\n",
        "            return (x & y) | (~x & z)\n",
        "        if 32 <= j <= 47:\n",
        "            return (x | ~y) ^ z\n",
        "        if 48 <= j <= 63:\n",
        "            return (x & z) | (y & ~z)\n",
        "        return x ^ (y | ~z)\n",
        "\n",
        "    r1 = [\n",
        "        0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n",
        "        7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,\n",
        "        3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,\n",
        "        1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,\n",
        "        4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13\n",
        "    ]\n",
        "    r2 = [\n",
        "        5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,\n",
        "        6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,\n",
        "        15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,\n",
        "        8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,\n",
        "        12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11\n",
        "    ]\n",
        "    s1 = [\n",
        "        11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,\n",
        "        7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,\n",
        "        11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,\n",
        "        11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,\n",
        "        9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6\n",
        "    ]\n",
        "    s2 = [\n",
        "        8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,\n",
        "        9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,\n",
        "        9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,\n",
        "        15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,\n",
        "        8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11\n",
        "    ]\n",
        "\n",
        "    K1 = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\n",
        "    K2 = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\n",
        "\n",
        "    ml = len(data)\n",
        "    data += bytes([0x80])\n",
        "    data += bytes([0x00]) * ((56 - (ml + 1) % 64) % 64)\n",
        "    data += (ml * 8).to_bytes(8, 'little')\n",
        "\n",
        "    h0 = 0x67452301\n",
        "    h1 = 0xefcdab89\n",
        "    h2 = 0x98badcfe\n",
        "    h3 = 0x10325476\n",
        "    h4 = 0xc3d2e1f0\n",
        "\n",
        "    for i in range(0, len(data), 64):\n",
        "        block = data[i:i+64]\n",
        "        X = [int.from_bytes(block[j:j+4], 'little') for j in range(0, 64, 4)]\n",
        "\n",
        "        A1, B1, C1, D1, E1 = h0, h1, h2, h3, h4\n",
        "        A2, B2, C2, D2, E2 = h0, h1, h2, h3, h4\n",
        "\n",
        "        for j in range(80):\n",
        "            T = (rol((A1 + f(j, B1, C1, D1) + X[r1[j]] + K1[j // 16]) & 0xffffffff, s1[j]) + E1) & 0xffffffff\n",
        "            A1, E1, D1, C1, B1 = E1, D1, rol(C1, 10), B1, T\n",
        "\n",
        "            T = (rol((A2 + f(79 - j, B2, C2, D2) + X[r2[j]] + K2[j // 16]) & 0xffffffff, s2[j]) + E2) & 0xffffffff\n",
        "            A2, E2, D2, C2, B2 = E2, D2, rol(C2, 10), B2, T\n",
        "\n",
        "        T = (h1 + C1 + D2) & 0xffffffff\n",
        "        h1 = (h2 + D1 + E2) & 0xffffffff\n",
        "        h2 = (h3 + E1 + A2) & 0xffffffff\n",
        "        h3 = (h4 + A1 + B2) & 0xffffffff\n",
        "        h4 = (h0 + B1 + C2) & 0xffffffff\n",
        "        h0 = T\n",
        "\n",
        "    return (h0.to_bytes(4, 'little') + h1.to_bytes(4, 'little') + h2.to_bytes(4, 'little') + h3.to_bytes(4, 'little') + h4.to_bytes(4, 'little'))\n",
        "\n",
        "def ripemd160(b: bytes) -> bytes:\n",
        "    try:\n",
        "        h = hashlib.new('ripemd160')\n",
        "        h.update(b)\n",
        "        return h.digest()\n",
        "    except Exception:\n",
        "        return _ripemd160_py(b)\n",
        "\n",
        "def hash160(b: bytes) -> bytes:\n",
        "    return ripemd160(sha256(b))\n",
        "\n",
        "def base58_encode(b: bytes) -> str:\n",
        "    n = int.from_bytes(b, 'big')\n",
        "    res = ''\n",
        "    while n > 0:\n",
        "        n, r = divmod(n, 58)\n",
        "        res = BASE58_ALPHABET[r] + res\n",
        "    pad = 0\n",
        "    for c in b:\n",
        "        if c == 0:\n",
        "            pad += 1\n",
        "        else:\n",
        "            break\n",
        "    return '1' * pad + (res or '1')\n",
        "\n",
        "def base58_decode(s: str) -> bytes:\n",
        "    n = 0\n",
        "    for ch in s:\n",
        "        n = n * 58 + BASE58_ALPHABET.index(ch)\n",
        "    full = n.to_bytes((n.bit_length() + 7) // 8, 'big') if n else b''\n",
        "    pad = 0\n",
        "    for ch in s:\n",
        "        if ch == '1':\n",
        "            pad += 1\n",
        "        else:\n",
        "            break\n",
        "    return bytes([0]) * pad + full\n",
        "\n",
        "def base58check_encode(version: bytes, payload: bytes) -> str:\n",
        "    data = version + payload\n",
        "    checksum = hash256(data)[:4]\n",
        "    return base58_encode(data + checksum)\n",
        "\n",
        "def base58check_decode(s: str):\n",
        "    raw = base58_decode(s)\n",
        "    if len(raw) < 5:\n",
        "        raise ValueError('Invalid base58check')\n",
        "    data, checksum = raw[:-4], raw[-4:]\n",
        "    if hash256(data)[:4] != checksum:\n",
        "        raise ValueError('Invalid checksum')\n",
        "    return data[:1], data[1:]\n",
        "\n",
        "def int_to_le(n: int, size: int) -> bytes:\n",
        "    return n.to_bytes(size, 'little')\n",
        "\n",
        "def encode_varint(n: int) -> bytes:\n",
        "    if n < 0xfd:\n",
        "        return bytes([n])\n",
        "    if n <= 0xffff:\n",
        "        return bytes([0xfd]) + int_to_le(n, 2)\n",
        "    if n <= 0xffffffff:\n",
        "        return bytes([0xfe]) + int_to_le(n, 4)\n",
        "    return bytes([0xff]) + int_to_le(n, 8)\n",
        "\n",
        "def push_data(data: bytes) -> bytes:\n",
        "    l = len(data)\n",
        "    if l < 0x4c:\n",
        "        return bytes([l]) + data\n",
        "    if l <= 0xff:\n",
        "        return bytes([0x4c]) + bytes([l]) + data\n",
        "    if l <= 0xffff:\n",
        "        return bytes([0x4d]) + int_to_le(l, 2) + data\n",
        "    return bytes([0x4e]) + int_to_le(l, 4) + data\n",
        "\n",
        "OP_0 = bytes([0x00])\n",
        "OP_1 = bytes([0x51])\n",
        "OP_2 = bytes([0x52])\n",
        "OP_DUP = bytes([0x76])\n",
        "OP_HASH160 = bytes([0xa9])\n",
        "OP_EQUAL = bytes([0x87])\n",
        "OP_EQUALVERIFY = bytes([0x88])\n",
        "OP_CHECKSIG = bytes([0xac])\n",
        "OP_CHECKMULTISIG = bytes([0xae])\n",
        "OP_RETURN = bytes([0x6a])\n",
        "\n",
        "def privkey_to_pubkey(priv: bytes) -> bytes:\n",
        "    sk = SigningKey.from_string(priv, curve=SECP256k1)\n",
        "    vk = sk.get_verifying_key()\n",
        "    x = vk.pubkey.point.x()\n",
        "    y = vk.pubkey.point.y()\n",
        "    prefix = bytes([0x02]) if (y % 2 == 0) else bytes([0x03])\n",
        "    return prefix + x.to_bytes(32, 'big')\n",
        "\n",
        "def sign_digest_low_s(priv: bytes, digest: bytes) -> bytes:\n",
        "    sk = SigningKey.from_string(priv, curve=SECP256k1)\n",
        "    sig = sk.sign_digest_deterministic(digest, hashfunc=hashlib.sha256, sigencode=util.sigencode_string)\n",
        "    r = int.from_bytes(sig[:32], 'big')\n",
        "    s = int.from_bytes(sig[32:], 'big')\n",
        "    order = SECP256k1.order\n",
        "    if s > order // 2:\n",
        "        s = order - s\n",
        "    return util.sigencode_der(r, s, order)\n",
        "\n",
        "def script_p2pkh(h160: bytes) -> bytes:\n",
        "    return OP_DUP + OP_HASH160 + push_data(h160) + OP_EQUALVERIFY + OP_CHECKSIG\n",
        "\n",
        "def script_p2sh(h160: bytes) -> bytes:\n",
        "    return OP_HASH160 + push_data(h160) + OP_EQUAL\n",
        "\n",
        "def script_op_return(data: bytes) -> bytes:\n",
        "    return OP_RETURN + push_data(data)\n",
        "\n",
        "def serialize_tx(version: int, inputs, outputs, locktime: int = 0) -> bytes:\n",
        "    res = int_to_le(version, 4)\n",
        "    res += encode_varint(len(inputs))\n",
        "    for inp in inputs:\n",
        "        res += inp['txid']\n",
        "        res += int_to_le(inp['vout'], 4)\n",
        "        res += encode_varint(len(inp['scriptSig'])) + inp['scriptSig']\n",
        "        res += int_to_le(inp.get('sequence', 0xffffffff), 4)\n",
        "    res += encode_varint(len(outputs))\n",
        "    for out in outputs:\n",
        "        res += int_to_le(out['value'], 8)\n",
        "        res += encode_varint(len(out['scriptPubKey'])) + out['scriptPubKey']\n",
        "    res += int_to_le(locktime, 4)\n",
        "    return res\n",
        "\n",
        "def signature_hash(version: int, inputs, outputs, input_index: int, script_code: bytes, locktime: int = 0, sighash_type: int = 1) -> bytes:\n",
        "    tmp_inputs = []\n",
        "    for i, inp in enumerate(inputs):\n",
        "        script = script_code if i == input_index else b''\n",
        "        tmp_inputs.append({**inp, 'scriptSig': script})\n",
        "    preimage = serialize_tx(version, tmp_inputs, outputs, locktime) + int_to_le(sighash_type, 4)\n",
        "    return hash256(preimage)\n",
        "\n",
        "def sign_p2pkh_input(priv: bytes, pub: bytes, inputs, outputs, input_index: int, script_code: bytes, version: int = 1, locktime: int = 0) -> bytes:\n",
        "    z = signature_hash(version, inputs, outputs, input_index, script_code, locktime)\n",
        "    sig = sign_digest_low_s(priv, z) + bytes([1])\n",
        "    return push_data(sig) + push_data(pub)\n",
        "\n",
        "def sign_p2sh_multisig_input(privkeys, inputs, outputs, input_index: int, redeem_script: bytes, version: int = 1, locktime: int = 0) -> bytes:\n",
        "    z = signature_hash(version, inputs, outputs, input_index, redeem_script, locktime)\n",
        "    sigs = []\n",
        "    for priv in privkeys:\n",
        "        sig = sign_digest_low_s(priv, z) + bytes([1])\n",
        "        sigs.append(sig)\n",
        "    return OP_0 + b''.join(push_data(s) for s in sigs) + push_data(redeem_script)\n",
        "\n",
        "def txid_from_raw(raw: bytes) -> str:\n",
        "    return hash256(raw)[::-1].hex()\n",
        "\n",
        "def pubkey_to_p2pkh_address(pubkey: bytes, testnet: bool = True) -> str:\n",
        "    version = bytes([0x6f]) if testnet else bytes([0x00])\n",
        "    return base58check_encode(version, hash160(pubkey))\n",
        "\n",
        "def redeem_script_to_p2sh_address(redeem_script: bytes, testnet: bool = True) -> str:\n",
        "    version = bytes([0xc4]) if testnet else bytes([0x05])\n",
        "    return base58check_encode(version, hash160(redeem_script))\n",
        "\n",
        "def address_to_h160(addr: str):\n",
        "    version, payload = base58check_decode(addr)\n",
        "    return version[0], payload\n",
        "\n",
        "def estimate_fee(input_sizes, output_scripts, fee_rate: int) -> int:\n",
        "    size = 10 + sum(input_sizes)\n",
        "    for s in output_scripts:\n",
        "        size += 8 + 1 + len(s)\n",
        "    return size * fee_rate\n",
        "\n",
        "API_BASES = [\n",
        "    'https://blockstream.info/testnet/api',\n",
        "    'https://mempool.space/testnet/api',\n",
        "]\n",
        "\n",
        "def fetch_utxos(address: str):\n",
        "    last_err = None\n",
        "    for base in API_BASES:\n",
        "        try:\n",
        "            r = requests.get(f'{base}/address/{address}/utxo', timeout=20)\n",
        "            if r.status_code == 200:\n",
        "                return r.json()\n",
        "            last_err = r.text\n",
        "        except Exception as e:\n",
        "            last_err = str(e)\n",
        "    raise RuntimeError(f'UTXO fetch failed: {last_err}')\n",
        "\n",
        "def broadcast_tx(raw_hex: str):\n",
        "    last_err = None\n",
        "    for base in API_BASES:\n",
        "        try:\n",
        "            r = requests.post(f'{base}/tx', data=raw_hex, timeout=20)\n",
        "            if r.status_code == 200:\n",
        "                return r.text.strip(), base\n",
        "            last_err = r.text\n",
        "        except Exception as e:\n",
        "            last_err = str(e)\n",
        "    raise RuntimeError(f'Broadcast failed: {last_err}')\n",
        "\n",
        "def check_tx(txid: str) -> bool:\n",
        "    for base in API_BASES:\n",
        "        try:\n",
        "            r = requests.get(f'{base}/tx/{txid}', timeout=20)\n",
        "            if r.status_code == 200:\n",
        "                return True\n",
        "        except Exception:\n",
        "            pass\n",
        "    return False\n",
        "\n",
        "def select_utxo(utxos, prefer_txid: str | None = None):\n",
        "    if prefer_txid:\n",
        "        for u in utxos:\n",
        "            if u.get('txid') == prefer_txid:\n",
        "                return u\n",
        "    utxos_sorted = sorted(utxos, key=lambda x: x['value'], reverse=True)\n",
        "    return utxos_sorted[0] if utxos_sorted else None\n",
        "\n",
        "def split_step3_amounts(total: int, min_addr2: int = 12000) -> tuple[int, int]:\n",
        "    if total <= min_addr2 + 1000:\n",
        "        raise RuntimeError('Insufficient funds for step3 outputs')\n",
        "    amt_addr2 = min(20000, total // 2)\n",
        "    if amt_addr2 < min_addr2:\n",
        "        amt_addr2 = min_addr2\n",
        "    amt_multisig = total - amt_addr2\n",
        "    if amt_multisig <= 0:\n",
        "        raise RuntimeError('Insufficient funds for multisig output')\n",
        "    return amt_addr2, amt_multisig\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "sk1 = os.urandom(32)\n",
        "sk2 = os.urandom(32)\n",
        "pub1 = privkey_to_pubkey(sk1)\n",
        "pub2 = privkey_to_pubkey(sk2)\n",
        "\n",
        "Address_1 = pubkey_to_p2pkh_address(pub1, testnet=True)\n",
        "Address_2 = pubkey_to_p2pkh_address(pub2, testnet=True)\n",
        "\n",
        "redeem_script = OP_2 + push_data(pub1) + push_data(pub2) + OP_2 + OP_CHECKMULTISIG\n",
        "MultiSig_Address = redeem_script_to_p2sh_address(redeem_script, testnet=True)\n",
        "Redeem_Script_hex = redeem_script.hex()\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Faucet: send testnet BTC to `Address_1`, then set `FAUCET_TXID` below.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "FAUCET_TXID = ''  # set after faucet\n",
        "MANUAL_UTXOS = None  # optional list of dicts: [{'txid':..., 'vout':..., 'value':...}]\n",
        "\n",
        "utxos = fetch_utxos(Address_1) if MANUAL_UTXOS is None else MANUAL_UTXOS\n",
        "if not utxos:\n",
        "    raise RuntimeError('No UTXOs for Address_1. Fund the address and/or set MANUAL_UTXOS.')\n",
        "\n",
        "utxo = select_utxo(utxos, prefer_txid=FAUCET_TXID or None)\n",
        "if utxo is None:\n",
        "    raise RuntimeError('Specified FAUCET_TXID not found in UTXOs.')\n",
        "\n",
        "Faucet_Transaction_ID = utxo['txid']\n",
        "prev_txid_le = bytes.fromhex(utxo['txid'])[::-1]\n",
        "prev_vout = utxo['vout']\n",
        "prev_value = utxo['value']\n",
        "\n",
        "h160_1 = hash160(pub1)\n",
        "h160_2 = hash160(pub2)\n",
        "\n",
        "script_pubkey_1 = script_p2pkh(h160_1)\n",
        "script_pubkey_2 = script_p2pkh(h160_2)\n",
        "script_pubkey_multisig = script_p2sh(hash160(redeem_script))\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "FEE_RATE = 5  # sat/vB; will auto-increase on fee errors\n",
        "\n",
        "def build_step3(fee_rate: int):\n",
        "    inputs = [{\n",
        "        'txid': prev_txid_le,\n",
        "        'vout': prev_vout,\n",
        "        'scriptSig': b'',\n",
        "        'sequence': 0xffffffff,\n",
        "    }]\n",
        "    output_scripts = [script_pubkey_2, script_pubkey_multisig]\n",
        "    fee = estimate_fee([148], output_scripts, fee_rate)\n",
        "    total = prev_value - fee\n",
        "    amt_addr2, amt_multisig = split_step3_amounts(total)\n",
        "    outputs = [\n",
        "        {'value': amt_addr2, 'scriptPubKey': script_pubkey_2},\n",
        "        {'value': amt_multisig, 'scriptPubKey': script_pubkey_multisig},\n",
        "    ]\n",
        "    script_sig = sign_p2pkh_input(sk1, pub1, inputs, outputs, 0, script_pubkey_1)\n",
        "    inputs_signed = [{**inputs[0], 'scriptSig': script_sig}]\n",
        "    raw = serialize_tx(1, inputs_signed, outputs, 0)\n",
        "    return raw, txid_from_raw(raw), outputs, fee\n",
        "\n",
        "def build_and_broadcast_step3(fee_rate: int, max_tries: int = 4):\n",
        "    last_err = None\n",
        "    for _ in range(max_tries):\n",
        "        raw, txid, outputs, fee = build_step3(fee_rate)\n",
        "        try:\n",
        "            txid_b, _ = broadcast_tx(raw.hex())\n",
        "            _ = check_tx(txid_b)\n",
        "            return raw, txid_b, outputs, fee, fee_rate, None\n",
        "        except Exception as e:\n",
        "            msg = str(e)\n",
        "            last_err = msg\n",
        "            if 'fee' in msg.lower() or 'non-mandatory-script-verify-flag' in msg.lower():\n",
        "                fee_rate += 2\n",
        "                continue\n",
        "            return raw, txid, outputs, fee, fee_rate, msg\n",
        "    return raw, txid, outputs, fee, fee_rate, last_err\n",
        "\n",
        "RAW_step3, TXID_step3, step3_outputs, fee_step3, fee_rate_step3, step3_broadcast_error = build_and_broadcast_step3(FEE_RATE)\n",
        "STEP3_ADDR2_VOUT = 0\n",
        "STEP3_MULTISIG_VOUT = 1\n",
        "STEP3_ADDR2_VALUE = step3_outputs[0]['value']\n",
        "STEP3_MULTISIG_VALUE = step3_outputs[1]['value']\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "OP_RETURN_TEXT = 'Lastname FirstName'\n",
        "\n",
        "def build_step4(fee_rate: int):\n",
        "    inputs = [{\n",
        "        'txid': bytes.fromhex(TXID_step3)[::-1],\n",
        "        'vout': STEP3_ADDR2_VOUT,\n",
        "        'scriptSig': b'',\n",
        "        'sequence': 0xffffffff,\n",
        "    }]\n",
        "    opret_script = script_op_return(OP_RETURN_TEXT.encode())\n",
        "    change_script = script_pubkey_1\n",
        "    output_scripts = [opret_script, change_script]\n",
        "    fee = estimate_fee([148], output_scripts, fee_rate)\n",
        "    change_value = STEP3_ADDR2_VALUE - fee\n",
        "    if change_value <= 600:\n",
        "        raise RuntimeError('Insufficient funds for step4 change output')\n",
        "    outputs = [\n",
        "        {'value': 0, 'scriptPubKey': opret_script},\n",
        "        {'value': change_value, 'scriptPubKey': change_script},\n",
        "    ]\n",
        "    script_sig = sign_p2pkh_input(sk2, pub2, inputs, outputs, 0, script_pubkey_2)\n",
        "    inputs_signed = [{**inputs[0], 'scriptSig': script_sig}]\n",
        "    raw = serialize_tx(1, inputs_signed, outputs, 0)\n",
        "    return raw, txid_from_raw(raw), outputs, fee\n",
        "\n",
        "def build_and_broadcast_step4(fee_rate: int, max_tries: int = 4):\n",
        "    last_err = None\n",
        "    for _ in range(max_tries):\n",
        "        raw, txid, outputs, fee = build_step4(fee_rate)\n",
        "        try:\n",
        "            txid_b, _ = broadcast_tx(raw.hex())\n",
        "            _ = check_tx(txid_b)\n",
        "            return raw, txid_b, outputs, fee, fee_rate, None\n",
        "        except Exception as e:\n",
        "            msg = str(e)\n",
        "            last_err = msg\n",
        "            if 'fee' in msg.lower() or 'non-mandatory-script-verify-flag' in msg.lower():\n",
        "                fee_rate += 2\n",
        "                continue\n",
        "            return raw, txid, outputs, fee, fee_rate, msg\n",
        "    return raw, txid, outputs, fee, fee_rate, last_err\n",
        "\n",
        "RAW_step4, TXID_step4, step4_outputs, fee_step4, fee_rate_step4, step4_broadcast_error = build_and_broadcast_step4(FEE_RATE)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "TARGET_ADDRESS = 'n2jmkNzxLJM51AvH3WNyYgWpsrjvR5HnF8'\n",
        "\n",
        "def build_step5(fee_rate: int):\n",
        "    inputs = [{\n",
        "        'txid': bytes.fromhex(TXID_step3)[::-1],\n",
        "        'vout': STEP3_MULTISIG_VOUT,\n",
        "        'scriptSig': b'',\n",
        "        'sequence': 0xffffffff,\n",
        "    }]\n",
        "    v, h160 = address_to_h160(TARGET_ADDRESS)\n",
        "    if v != 0x6f:\n",
        "        raise RuntimeError('Target address is not testnet P2PKH')\n",
        "    target_script = script_p2pkh(h160)\n",
        "    output_scripts = [target_script]\n",
        "    fee = estimate_fee([330], output_scripts, fee_rate)\n",
        "    send_value = STEP3_MULTISIG_VALUE - fee\n",
        "    if send_value <= 600:\n",
        "        raise RuntimeError('Insufficient funds for step5 output')\n",
        "    outputs = [\n",
        "        {'value': send_value, 'scriptPubKey': target_script},\n",
        "    ]\n",
        "    script_sig = sign_p2sh_multisig_input([sk1, sk2], inputs, outputs, 0, redeem_script)\n",
        "    inputs_signed = [{**inputs[0], 'scriptSig': script_sig}]\n",
        "    raw = serialize_tx(1, inputs_signed, outputs, 0)\n",
        "    return raw, txid_from_raw(raw), outputs, fee\n",
        "\n",
        "def build_and_broadcast_step5(fee_rate: int, max_tries: int = 4):\n",
        "    last_err = None\n",
        "    for _ in range(max_tries):\n",
        "        raw, txid, outputs, fee = build_step5(fee_rate)\n",
        "        try:\n",
        "            txid_b, _ = broadcast_tx(raw.hex())\n",
        "            _ = check_tx(txid_b)\n",
        "            return raw, txid_b, outputs, fee, fee_rate, None\n",
        "        except Exception as e:\n",
        "            msg = str(e)\n",
        "            last_err = msg\n",
        "            if 'fee' in msg.lower() or 'non-mandatory-script-verify-flag' in msg.lower():\n",
        "                fee_rate += 2\n",
        "                continue\n",
        "            return raw, txid, outputs, fee, fee_rate, msg\n",
        "    return raw, txid, outputs, fee, fee_rate, last_err\n",
        "\n",
        "RAW_step5, TXID_step5, step5_outputs, fee_step5, fee_rate_step5, step5_broadcast_error = build_and_broadcast_step5(FEE_RATE)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "print(f'Address_1: {Address_1}')\n",
        "print(f'Address_2: {Address_2}')\n",
        "print(f'MultiSig Address: {MultiSig_Address}')\n",
        "print(f'Redeem Script (hex): {Redeem_Script_hex}')\n",
        "print(f'Faucet Transaction_ID: {Faucet_Transaction_ID}')\n",
        "print(f'TXID_step3: {TXID_step3}')\n",
        "print(f'TXID_step4: {TXID_step4}')\n",
        "print(f'TXID_step5: {TXID_step5}')\n"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
